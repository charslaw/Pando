using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using Pando.SerializerGenerator.Utils;

namespace Pando.SerializerGenerator;

[Generator]
public class SerializerIncrementalGenerator : IIncrementalGenerator
{
	private const string MARKER_ATTRIBUTE_SHORT = "GenerateNodeSerializer";
	private const string MARKER_ATTRIBUTE = "GenerateNodeSerializerAttribute";

	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
#if DEBUG
		// if (!Debugger.IsAttached) Debugger.Launch();
#endif

		var symbols = CollectSymbols(context);

		context.RegisterSourceOutput(symbols,
			static (ctx, symbols) =>
			{
				if (symbols.IsDefaultOrEmpty) return;

				var typesAndCtorParams = new List<(INamedTypeSymbol, ImmutableArray<IParameterSymbol>)>();

				foreach (var symbol in symbols)
				{
					if (symbol is not INamedTypeSymbol typeSymbol) continue;

					var attribute = typeSymbol.GetAttributes().First(static it => it.AttributeClass?.Name == MARKER_ATTRIBUTE);
					var attributeSyntax = attribute.ApplicationSyntaxReference?.GetSyntax() as AttributeSyntax;

					var validationResult = CandidateTypeValidator.ValidateCandidateType(typeSymbol, attributeSyntax);

					switch (validationResult)
					{
						case CandidateTypeValidator.ValidateResult.Invalid invalidResult:
							ctx.ReportDiagnostic(invalidResult.Diagnostic);
							break;
						case CandidateTypeValidator.ValidateResult.Valid validResult:
							typesAndCtorParams.Add((typeSymbol, validResult.ParamArray));
							break;
					}
				}

				WriteSources(typesAndCtorParams, ctx);
			}
		);
	}

	/// Collect types that have the generate serializer marker attribute *and* all Deconstruct methods.
	/// We collect deconstruct methods explicitly rather than going through the type directly because a deconstructor can be an extension method,
	/// which will not be on the type itself.
	/// We'll filter the deconstruct methods to only those on the types in question later.
	private static IncrementalValueProvider<ImmutableArray<ISymbol>> CollectSymbols(IncrementalGeneratorInitializationContext context)
		=> context.SyntaxProvider.CreateSyntaxProvider(
				predicate: static (syntax, _) =>
				{
					if (syntax is not TypeDeclarationSyntax { AttributeLists.Count: > 0 } tds) return false;

					foreach (var attrList in tds.AttributeLists)
					{
						foreach (var attr in attrList.Attributes)
						{
							var attrName = attr.Name.ToString();
							if (attrName is MARKER_ATTRIBUTE_SHORT or MARKER_ATTRIBUTE) return true;
						}
					}

					return false;
				},
				transform: static (ctx, _) => ctx.SemanticModel.GetDeclaredSymbol(ctx.Node)
			)
			.Where(static sym => sym is not null)
			.Collect();

	private static void WriteSources(IEnumerable<(INamedTypeSymbol, ImmutableArray<IParameterSymbol>)> types, SourceProductionContext spCtx)
	{
		var printAllCandidatesContents = new StringBuilder();
		foreach (var (type, ctorParams) in types)
		{
			var typeString = type.ToDisplayString(CustomSymbolDisplayFormats.NestedTypeName);
			printAllCandidatesContents.AppendLine($"\n\t\tsb.AppendLine(\"\\nValid Type: {typeString}:\");");
			printAllCandidatesContents.AppendLine($"\t\tsb.AppendLine(\"\\tConstructor Params: [{string.Join(", ", ctorParams)}]\");");
		}

		var text = @$"// <auto-generated />
using System.Text;
using System.CodeDom.Compiler;

namespace GeneratedNamespace;

[GeneratedCode(""{typeof(SerializerIncrementalGenerator).Assembly.GetName().Name}"", """")]
public static class ColesTestClass
{{
	public static void PrintAllCandidates(StringBuilder sb)
	{{
		{printAllCandidatesContents}
	}}
}}
";
		spCtx.AddSource("ColesTestClass.g.cs", SourceText.From(text, Encoding.UTF8));
	}
}
